#' Rolling window function
#'
#' 
#'
#' @param lag 
#' @param data 
#' @param model 
#' @param N
#'
#' @return A matrix of observations with dimensions Time x d.
#' @export
Orc_SMC <- function(lag, data, model, N) {
  obs <- data$obs
  Time <- nrow(obs)
  d = ncol(obs)
  lag = lag
  A <- model$tran_mu
  B <- model$tran_cov
  obs_params <- model$obs_params
  K <- model$parameters$k
  # Initialize particle system storage
  #H <- list() #final particles with normalizing constant
  #H_tilde <- list() #generated by inner psi-APF
  
  # Initial state: X is a (d x N) matrix, W is a vector, Z is scalar
  X0 = matrix(0, nrow = N, ncol = d)
  w0 = matrix(log(1/N), 1, N)
  #logZ = 0 
  logZ_vec <- numeric(Time)
  
  #the size of the data can be changed
  X = X_apf = array(NA, c(Time, N, d))
  #w = w_apf = W_nor = W_n = matrix(NA, Time, N) 
  log_W_apf = log_W = matrix(NA, Time, N) 
  log_likelihoods = log_likelihoods_apf<- matrix(NA, Time, N)
  filtering_estimates <- matrix(NA, Time, d) 
  
  #probably can be updated to 1st line once t reaches L
  psi_pa <- matrix(NA, Time, 2*d)
  #H[[0]] <- list(X = matrix(0, nrow = d, ncol = N), W = rep(1/N, N), Z = 1)
  #H_tilde[[0]] <- H[[0]]

  # Main loop for t = 1, ..., T
  for (t in 1:Time) {
    t0 <- max(t - lag + 1, 1)
    # Step 1: Optional deletion to reduce memory cost
    #if (t - 1 > L) {
    # H[[t - 1 - L]] <- NULL
    #  H_tilde[[t - 1 - L]] <- NULL
    #}
    
    # Step 2: Set ψ_t = 1
    #psi_t <- 1 probably need to set this within psi-apf as final time
    
    # Step 3: Compute H_tilde using ψ-APF
    
    ###init###
    if(t == 1){
      #X_ini = X0
      #w_ini = w0
      H_prev <- list(X = X0, logW = w0)
    }else{
      H_prev <- list(X = X_apf[t-1,,], logW = log_W_apf[t-1,])
    }
    
    #output <- run_psi_APF_rolling(model, list(obs[t,, drop = FALSE], c(t,t), X_ini, w_ini), 
    #           Napf, 0, init = TRUE)
    output <- run_psi_APF_rolling(data, t, psi_pa, H_prev, model, init = TRUE) 
    X_apf[t,,] <- output$X
    log_W_apf[t,] <- output$logW
    log_likelihoods_apf[t,] <- output$log_likelihoods
    
    ###init###
    
    # Step 4: Iterative updating
    for (k in 1:K) {
      psi_pa[t0:t,] <- learn_psi(X_apf[t0:t,,, drop = FALSE], obs[t0:t,, drop = FALSE],
                                 model, log_likelihoods_apf[t0:t,,drop = FALSE])
      
      for(s in t0:t){
        if(s == 1){
          H_prev <- list(X = X0, logW = w0)
        }else{
          H_prev <- list(X = X_apf[s - 1,,], logW = log_W_apf[s - 1,])
        }
        
        output <- run_psi_APF_rolling(data, s, psi_pa, H_prev, model, init = FALSE)
        X_apf[s,,] <- output$X
        log_W_apf[s,] <- output$logW
        log_likelihoods_apf[s,] <- output$log_likelihoods
      }
      #if(t > lag){
      # output <- run_psi_APF_rolling(model, list(obs[t0:t,, drop = FALSE], c(t0,t), X_apf[t0 - 1,,], W_nor[t0 - 1,]), 
      #                              Napf, psi_pa, init = FALSE)
      #}else{
      # output <- run_psi_APF_rolling(model, list(obs[t0:t,, drop = FALSE], c(t0,t), X0, w0), 
      #                              Napf, psi_pa, init = FALSE)
      #}
      
    }
   
    # Step 5: Store results
    if (t == Time) {
      if(t - lag + 1 == 1){
        H_prev <- list(X = X0, logW = w0)
      }else{
        H_prev <- list(X = X[t - lag,,], logW = log_W[t - lag,])
      }
      
      for(s in  t0:t){
        if(s == 1){
          H_prev <- list(X = X0, logW = w0)
        }else{
          H_prev <- list(X = X[s - 1,,], logW = log_W[s - 1,])
        }
        
        output <- run_psi_APF_rolling(data, s, psi_pa, H_prev, model, init = FALSE)
        X[s,,] <- output$X
        log_W[s,] <- output$logW
        
        #logZ <- output$logZ + logZ
        logZ_vec[s] <- if (s > 1) logZ_vec[s - 1] + output$logZ else output$logZ
        #logZ <- logZ + normalise_weights_in_log_space(w[Time,])[[2]] 
        #print(logZ)
        
        W_t <- normalise_weights_in_log_space(log_W[s,])[[1]] 
        filtering_estimates[s,] <- colSums(W_t * X[s,,])
        }
      
     
    
    } else if (t > lag - 1) {
      
      if(t - lag + 1 == 1){
        H_prev <- list(X = X0, logW = w0)
      }else{
        H_prev <- list(X = X[t - lag,,], logW = log_W[t - lag,])
      }
      
      output <- run_psi_APF_rolling(data, t - lag + 1, psi_pa, H_prev, model, init = FALSE)
      X[t - lag + 1,,] <- output$X
      log_W[t - lag + 1,] <- output$logW
      
      #logZ <- output$logZ + logZ
      logZ_vec[t - lag + 1] <- if ((t - lag + 1) > 1) logZ_vec[t - lag] + output$logZ else output$logZ
      #print(logZ_vec)
      #log_likelihoods[t,] <- output[[5]]
      W_t <- normalise_weights_in_log_space(log_W[t - lag + 1,])[[1]] 
      filtering_estimates[t - lag + 1,] <- colSums(W_t * X[t - lag + 1,,])
    }
    
    
  }
  
  
  
  return(list(logZ = logZ_vec, f_means = filtering_estimates))  
}

