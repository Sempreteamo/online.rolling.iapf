Orc_SMC <- function(N, K, L, T, d, ft, gt, approximateFilteringDistributions) {
  obs <- data$obs
  Time <- nrow(obs)
  d = ncol(obs)
  
  ini_mu <- model$ini_mu
  ini_cov <- model$ini_cov
  A <- model$tran_mu
  B <- model$tran_cov
  obs_params <- model$obs_params
  K <- model$parameters$k
  # Initialize particle system storage
  #H <- list() #final particles with normalizing constant
  #H_tilde <- list() #generated by inner psi-APF
  
  # Initial state: X is a (d x N) matrix, W is a vector, Z is scalar
  X0 = matrix(0, nrow = N, ncol = d)
  w0 = matrix(1/N, 1, N)
  logZ = 0 
  
  #the size of the data can be changed
  X = X_apf = array(NA, c(Time, N, d))
  w = w_apf = matrix(NA, Time, N) 
  log_likelihoods = log_likelihoods_apf<- matrix(NA, Time, N)
  
  #probably can be updated to 1st line once t reaches L
  psi_pa <- matrix(NA, Time, 2*d)
  #H[[0]] <- list(X = matrix(0, nrow = d, ncol = N), W = rep(1/N, N), Z = 1)
  #H_tilde[[0]] <- H[[0]]
  
  # Main loop for t = 1, ..., T
  for (t in 1:Time) {
    t0 <- max(t - lag + 1, 1)
    
    # Step 1: Optional deletion to reduce memory cost
    #if (t - 1 > L) {
     # H[[t - 1 - L]] <- NULL
    #  H_tilde[[t - 1 - L]] <- NULL
    #}
    
    # Step 2: Set ψ_t = 1
    #psi_t <- 1 probably need to set this within psi-apf as final time
    
    # Step 3: Compute H_tilde using ψ-APF
    
    ###init###
    if(t == 1){
      X_ini = X0
      w_ini = w0
    }else{
      X_ini = X_apf[t-1,,]
      w_ini = w_apf[t-1,]
    }
    
    output <- run_psi_APF_rolling(model, list(obs[t,, drop = FALSE], c(t,t), X_ini, w_ini), 
                Napf, 0, init = TRUE)
    X_apf[t,,] <- output[[1]] 
    w_apf[t,] <- output[[2]]
    log_likelihoods_apf[t,] <- output[[5]]
    ###init###
    
    # Step 4: Iterative updating
    for (k in 1:K) {
      psi_pa[t0:t,] <- learn_psi(X_apf[t0:t,,, drop = FALSE], obs[t0:t,, drop = FALSE],
                          model, log_likelihoods_apf[t0:t,,drop = FALSE])
      
      output <- run_psi_APF_rolling(model, list(obs[t0:t,, drop = FALSE], c(t0,t), X_ini, w_ini), 
                          Napf, psi_pa, init = FALSE)
      X_apf[t0:t,,] <- output[[1]]
      w_apf[t0:t,] <- output[[2]]
      log_likelihoods_apf[t0:t,] <- output[[5]]
    }
   
    # Step 5: Store results
    if (approximateFilteringDistributions == TRUE || t == Time) {
      output <- run_psi_APF_rolling(model, list(obs[t0:t,, drop = FALSE], c(t0,t), X_ini, w_ini), 
                                    Napf, psi_pa, init = FALSE)
      X[t0:t,,] <- output[[1]]
      w[t0:t,] <- output[[2]]
      
    } else if (t > lag - 1) {
      if(t - lag + 1 == 1){
        X_ini = X0
        w_ini = w0
      }else{
        X_ini = X[t - lag,,]
        w_ini = w[t - lag,]
      }
      
      output <- run_psi_APF_rolling(model, list(obs[t- lag + 1,, drop = FALSE], 
                                        c(t- lag + 1, t- lag + 1), X_ini, w_ini), 
                                    Napf, psi_pa, init = FALSE)
      X[t- lag + 1,,] <- output[[1]] 
      w[t- lag + 1,] <- output[[2]]
      #log_likelihoods[t,] <- output[[5]]
    }
  }
  
  
  }
}
