#' Function to run the iterated APF
#'
#' @param model Information of the model
#' @param data Information of the required data
#' @param Napf Number of particles users would like to generate
#'
#' @return A list contains:
#' X_apf is the particles generated by iAPF at the time of the upper boundary of the given block
#' w_apf is the weights generated by iAPF at the time of the upper boundary of the given block
#' psi_pa is the parameters of the distribution psi the algorithm finally choose
#' Z_apf is the estimated normalising constant
#' ancestors is all the indices of ancestors of particles during the algorithm
#'
#' @export
#'
run_iAPF <- function(model, data, Napf){
  breaks <- data$breaks
  obs <- data$obs
  run_block <- data$run_block
  past <- data$past
  
  w_apf_record <- past[[2]]
  X_apf_record <- past[[1]]
  
  index <- run_block[1]
  b_s <- run_block[2]
  b_e <- run_block[3]
  
  k <- model$parameters$k
  Time <- nrow(obs)
  d = ncol(obs)
  
  l = 1
  Z_apf <- vector()
  N[l] = Napf

  if(t == breaks[[index]][1]){
  
    output <- run_psi_APF(model, list(obs[1:b_e,],
                                      1: b_e, 0, as.matrix(0)), N[l], psi_pa = 0, init = TRUE) #high d pass
  
  }else{
   
    output <- run_psi_APF(model, list(obs[b_s:b_e,],
                                      b_s:b_e, 
                                      w_apf_record, 
                                      as.matrix(X_apf_record)), N[l],
                          psi_pa = 0, init = TRUE)
  }
 
  X_apf <- output[[1]]
  w_apf <- output[[2]]
  Z_apf[l] <- output[[3]]
  ancestors <- output[[4]]
  log_likelihoods <- output[[6]]
  
  while(TRUE){
    
    output <- list()
    
    if(l != 1){
      #generate filtering particles X_apf for psi the next iteration
      #APF outputs filtering X_apf for the next psi, and smoothing X_apf_s
      #for the final calculation
      
      output <- run_psi_APF(model, list(obs[b_s:b_e,],
                                        b_s: b_e, w_apf[nrow(w_apf),], as.matrix(X_apf[nrow(X_apf),,])),
                            N[l], psi_pa, init = FALSE)
      X_apf <- output[[1]]
      w_apf <- output[[2]]
      Z_apf[l] <- output[[3]]
      ancestors <- output[[4]]
      log_likelihoods <- output[[5]]
      
    }
    
    #to speed up the algorithm, I just fix the number of iterations to be k.
    #Here k = 5
    
    if(l <= k ){
      
      #receive filtering particles X_apf for psi
      psi_pa <- learn_psi(X_apf, obs[b_s:b_e,],
                          model, log_likelihoods)
      
      if(l > k & N[max(l-k,1)] == N[l] & is.unsorted(Z_apf[max(l-k,1):l])){
        N[l+1] <- 2*N[l]
        
      }else{
        N[l+1] <- N[l]
      }
      
      l <- l+1
    }else break
  }

  
  return(list(X_apf = X_apf[dim(X_apf)[1],,], w_apf = w_apf[nrow(w_apf),], psi_pa, Z_apf = Z_apf[l], ancestors))
}
